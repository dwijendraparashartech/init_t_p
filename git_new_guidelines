git_new_guidelines.txt



Git ::  For Git in Linux Mode :::



Some Basic Commands :: 

$ git –version - 
$ git config –-global user.name   --  Check   the UserName for Git Access.
$ git config -–global user.email   --  Check  the UserEmail for Git Access.
$ git config –-global user.name “abcemailid@gmail.com”  -- Set the UserName for Git Access.
$ git config -–global user.email “abc name”   --  Set the UserEmail for Git Access.
$ git status – check git status – What is the Status of Working Area in Git.
$ git add filename – Add a particular file to Staging area.
$ git diff file name – see the Changes in a Particular File.
$ git checkout filename – Unstage changes in a particular file.
$ git add .  - Add all files.in Staging Area 
$ git commit -m “commit name”  - Create the commit 
$ git config –global –edit 
$ git init   -  Initialized the repository
$ ls – nothing will show
$ ls -a  - show some git
$ git log  - command to check how many commits till now 
$ git branch – to check the branches of yours 
$ git branch -a  - to check all of the branches of remote repository
$ clear – to clear the terminal 
$ git remote -v   - to check the git remote repository 
$ git remote add origin ‘repositorylink’

-----------------------------------------------------------------

Install Git in Linux (Ubuntu) :: 

1.$ sudo apt-get update
2.$ sudo apt-get install git-all
3.$ git version 
4. $ git config --global color.ui auto
-----------------------------------------------------------------

Git Staging Enviornment ::

One of the core functions of Git is the concepts of the Staging Environment, and the Commit.
As you are working, you may be adding, editing and removing files. But whenever you hit a milestone or finish a part of the work, you should add the files to a Staging Environment.
Staged files are files that are ready to be committed to the repository you are working on. You will learn more about commit shortly.
-----------------------------------------------------------------




Clone the Github Project :: 
There are 3 ways to clone any github Project – copy the Remote Repository to Your Local System.

1.Through SSH Key
2.Through Token Access
3.Through Zip Folder Access.

------------------------------------------                         ------------------------------------------

1.Through SSH Key ::  Clone the project -- 

Step1 :  $ ssh-keygen -  Run this command at the terminal(Note – There will not be any space between ssh and keygen, only – will be there)


Step2  :  It may be ask to overwrite if you have created this before  -- 

this below like ::


this will give you path -

1. Public key save position  -- 
Your identification has been saved in /home/dwijendra/.ssh/id_rsa
Your public key has been saved in /home/dwijendra/.ssh/id_rsa.pub


2. Key fingerprint will come --
The key fingerprint is:
SHA256:36WlXOHKLJyeqg5f9Wfmd8kxnf6nihHgJZnqCtnJb0s dwijendra@aqusag-ThinkPad-T450

3.cat space ‘public key save position’
Run this command :: 
$cat  /home/dwijendra/.ssh/id_rsa.pub

Note – there will be space in this cat and the file path – only one space 
new ssh key will be generated by this – like this below -
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDGXtjNm1/gUftUSeW3m1jnPYBQpsZ5eTTnenb37voOGkciMkyUlFimXIfNzczHJEpZlrXvYRvHtPAoUUIjfzJXjC0e24JtCIOQq5v/lx+Iq+QDhrUFei0IlT0/RevuN+7VgbWkgJ5BGG4Un+a4DUcyALTpIJuwWWgrIwPWjUgeaMgEHRrslNJEfAYIDQR36c8HGLA0GMODACmgQsFjfV3PDKfKugxqxf9Dq7WOXoOgdh3JOPreXV9PxFDolf6GR0E4NZSx2RVF7V8DxUz2cGPyl0/rIrZi/9UO+wg2T2eoN0ohX/tZJ3Ddpdqjpo+CvmUYxjvPt4M0pRNM59NF8KH3xzbLsyLDORAyI7LZK7NbuhVA0wpe3gJ8gD4hiSZ22xkZBlxc+4/6VbvZJTgmj2G5gMBSyVAs0MbkPBTkFl3rckuLyRkmccJyOXm+V6L37bpuCGX56qOOtEUV45VAuqNshurPteS+K5wHsasX/SXUD3JhpTH+PpfLYTVgbsNmvBE= dwijendra@aqusag-ThinkPad-T450

4.Add this to your git hub  settings ::
4.1.In the top right corner – go to top right icon
4.1.1.Here go to settings
4.2.Here go to SSH and GPG keys -
4.3.Here go to new SSH key or Add SSH key
4.4. Paste above ssh key here -
4.4.1. title – add title

4.4.2. key – go to key
4.5.Go to button Add SSH Key

5. Run the Command to clone the remote repository to your local system --

$  git clone  ‘repository_clone_access_link’  - We will get it thorugh github website.

------------------------------------------                         ------------------------------------------

2.Through Token Access ::  Clone the project --

1.in the upper right corner - click settings.
2.in settings - in top below - click developer settings -
3.in developer settings - go to personal access tokens - there are 2 types of tokens-
3.1. fine grained tokens
3.2. personal access tokens.
Note – Github Recommends fine-grained PATs instead of PATs (classic)

5.Run the Command to clone the remote repository to your local system --

------------------------------------------                         ------------------------------------------

3.Download Zip.

------------------------------------------                         ------------------------------------------

-------------------------------------------------------------------------------------------------------

Git Working Areas :: 
Git contains 3 working areas:the Working Area, the Staging Area and the Repository.

Working Area ::
It is a place where your current code lives in, it contains not yet tracked files or untracked files. This is a place where you will add new content, new files, update or delete them. If these files exist in your repository, you won’t lose your work.
Staging Area  ::
It is the place where your changes are waiting for your next commit. They are ready to be committed, just waiting for you to actually do it. This is how Git knows what will change since the last commit.
Repository  ::
This is a secured place containing all the files Git knows about. It contains all your commits.

-------------------------------------------------------------------------------------------------------

Types of Branches :: 
    • Main
    • Develop
    • Feature
    • Release
    • Hotfix

Primary Branches ::
The two primary branches in Git flow are main and develop. 
Supporting Branches ::
There are three types of supporting branches with different intended purposes: feature, release, and hotfix.
........................................................................................................
It is based in two main branches with infinite lifetime:
master— this branch contains production code. All development code is merged into master in sometime.
develop — this branch contains pre-production code. When the features are finished then they are merged into develop.
During the development cycle, a variety of supporting branches are used:
feature-*— feature branches are used to develop new features for the upcoming releases. May branch off from develop and must merge into develop.
    • hotfix-*— hotfix branches are necessary to act immediately upon an undesired status of master. May branch off from master and must merge into master and develop.
    • release-*— release branches support preparation of a new production release. They allow many minor bug to be fixed and preparation of meta-data for a release. May branch off from develop and must merge into master and develop.

Note:: The thought process here is that you spend most of your time in  development. When in development, you create a feature branch (off of development), complete the feature, and then merge back into development. This can then be added to the final production version by merging into production.
........................................................................................................




Git Flow ::


Conflicts in Git and how to solve it  ::

Git Commands to Resolve Conflicts ::

1.git log –merge ::
The git log –merge command helps to produce the list of commits that are causing the conflict.

2.git diff  ::
The git diff command helps to identify the differences between the states repositories or files.

3.git checkout ::
The git checkout command is used to undo the changes made to the file,or for changing branches.

4.git reset –mixed :: 
The git reset –mixed command is used to undo changes to the working directory and staging area.

5.git merge –abort ::
The git merge –abort command helps in exiting the merge process and returning back to the state before the merging began.

6.git reset ::
The git reset command is used at the time of merge conflict to reset the conflicted files to their original state.

Some Basic Commands  ::

1.To see all commit -
$  git log 
The git log command enables you to display a list of all of the commits on your current branch.

2.Merge one branch to another branch – 
$ git merge [branch] 
merge the specified branch’s history into the current one

Specific Branch – git merge [branch] – this branch is the specific branch to that i will merge
Current Branch – current branch in which i will merge , this is the current existing branch at which i am in the git.

3.Stage Commands / Snapshot Commands -- 

1.$ git status -  show modified files in working directory, staged for your next commit
2.$ git add [file] - add a file as it looks now to your next commit (stage)
3.$ git reset [file]- unstage a file while retaining the changes in working directory
4.$ git diff - diff of what is changed but not staged
5.$ git diff – staged -- diff of what is staged but not yet commited
6.$ git commit -m “[descriptive message]” -- commit your staged content as a new commit snapshot

.....................................................................................................................................................

4.Tracking Path Changes --

1.$git log -- show the commit history for the currently active branch
2.$git log branchB..branchA – show the commits on branchA that are not on branchB
for example   --   $ git log  master..development    ::  Here master and development are two branches.
3.$ git log --follow [file] --   show the commits that changed file, even across renames
4.$ git diff branchB...branchA -- show the diff of what is in branchA that is not in branchB
5.$ git show [SHA] - show any object in Git in human-readable format
.....................................................................................................................................................

5.Git status command :: 
The git status command is used to display the state of the repository and staging area. It allows us to see the tracked, untracked files and changes. This command will not show any commit records or information.
$ git status 

.....................................................................................................................................................

5.Git Commit  command :: 

5.1. To get the list of commits and commit id ----
$  git log 

5.2.To revert the commit – after this command you can add files to git.There will be no any commit if you type git status :: 

$ git revert <commit-ish>
<commit-ish>  -- It is the commit id we can find in the git log or git log -t 

5.3.Edit the Commit 
$ git revert -e <commit-ish>

5.4.Find which commit is currently checked out in Git
$ git show
$ git log -1

5.5 If we want to find the commit by number on the current branch then we can check it by the specific number --
$ git log -2 
$ git log -3 
$ git log -1
$ git log -4

5.6. Show the last commit in short --
$ git show –oneline

5.7. Some more git log commands – Some Specific git log commands to add and show some more functionality in git ::

1.git log -stat :
It will show the commits in short.

2.git log --pretty=oneline
It will show all commits in oneline Means you can see the list of commits.

3.git log --pretty=short
It will show commits in short in a decorative way

4.git log --pretty=full
It will show commits in detail in a decorative way

5.git log –since=short
It will show commits in short.

6.git log –since=full
It will show commits in full.

7.git log –since=2.days
It will show commits in timeline.

8.git log –since=2.weeks
It will show commits in timeline.

.....................................................................................................................................................

6.Viewing project history :: 

6.1. $ git log 
At any point you can view the history of your changes using

6.2.$ git log -p 
If you also want to see complete diffs at each step, use

6.3.$ git log --stat –summary 
Often the overview of the change is useful to get a feel of each step

.....................................................................................................................................................

7.Important Commands ::  Of Remove Files :: 
7.1. Remove the file from the Repository ::
$  git rm <file Name>
The above command will remove the file from the Git and repository. The git rm command removes the file not only from the repository but also from the staging area. If we check the status of the repository, then it will show as deleted. Consider the below output:
7.2. Remove the file from the Repository ::
$  rm <file Name>
If we use only the rm command, then it will not permanently delete the file from the Git. It can be tracked in the staging area.
.........................................................................................................................................
8.Important Command :: Git Cherry Pick :: 
Cherry picking is the act of picking a commit from a branch and applying it to another.
With the "cherry-pick" command, Git allows you to integrate selected, individual commits from any branch into your current HEAD branch.

.........................................................................................................................................
9.Temporary Commits :: 
Temporarily store modified, tracked files in order to change branches --
$ git stash
Save modified and staged changes
$ git stash list
list stack-order of stashed file changes
$ git stash pop
write working from top of stash stack
$ git stash drop
discard the changes from top of stash stack
.........................................................................................................................................




9.Git Remote Commands :: 

1.$ git remote add origin ‘repository link’
2. $ git remote 
3. $ git remote -v

.........................................................................................................................................
10.How to push the code :: 

1.First add the file -
$ git add 

2.We can also add all files -
$ git add .

3.Create a commit -
$ git commit -m “commit name”

4.Push the code - 
$ git push origin ‘branch_name”
.........................................................................................................................................

11.Git Remote  :: 

1.$ git remote 
to check the remote 
2.$ git remote -v 
to check the remote version 
3. $ git remote add origin
to add the remote 

.........................................................................................................................................

12.List of Most Basic Git Commands everyone should know  -- 

1.$ git add – we add the files in the staging area here 
Moves changes from the working directory to the staging area. This gives you the opportunity to prepare a snapshot before committing it to the official history.


2.$ git branch – it will tell you branch name at which you are currently working.
This command is your general-purpose branch administration tool. It lets you create isolated development environments within a single repository.

3.$ git branch -a – it will tell you list of all branches associated with your project repository 
This command is your general-purpose branch administration tool. It lets you create isolated development environments within a single repository.

4.$ git checkout  – you can unstage your file or switch branches 
In addition to checking out old commits and old file revisions, git checkout is also the means to navigate existing branches. Combined with the basic Git commands, it’s a way to work on a particular line of development.

5.$ git clean  – remove untracked files from the working directory
Removes untracked files from the working directory. This is the logical counterpart to git reset, which (typically) only operates on tracked files.

6.$ git clone  – copy the project from your remote repository in your local system 
Creates a copy of an existing Git repository. Cloning is the most common way for developers to obtain a working copy of a central repository.

7.$ git commit  – commit the changes 
Takes the staged snapshot and commits it to the project history. Combined with git add, this defines the basic workflow for all Git users.

8.$ git commit-amend  –  amend the most recent commi
Passing the --amend flag to git commit lets you amend the most recent commit. This is very useful when you forget to stage a file or omit important information from the commit message.

9.$ git config –  configration options 
A convenient way to set configuration options for your Git installation. You’ll typically only need to use this immediately after installing Git on a new development machine.




10.$ git fetch –   downloads a branch from another repository
Fetching downloads a branch from another repository, along with all of its associated commits and files. But, it doesn't try to integrate anything into your local repository. This gives you a chance to inspect changes before merging them with your project.
11.$ git init –  initialized a repository 
Initializes a new Git repository. If you want to place a project under revision control, this is the first command you need to learn.

12. $git log – show the commits 
Lets you explore the previous revisions of a project. It provides several formatting options for displaying committed snapshots.
13. $ git merge -  use for merging 
A powerful way to integrate changes from divergent branches. After forking the project history with git branch, git merge lets you put it back together again.
14. $ git pull – use for take the updated code from branches.
Pulling is the automated version of git fetch. It downloads a branch from a remote repository, then immediately merges it into the current branch. This is the Git equivalent of svn update.
15. $ git push – use for push the code.
Pushing is the opposite of fetching (with a few caveats). It lets you move a local branch to another repository, which serves as a convenient way to publish contributions. This is like svn commit, but it sends a series of commits instead of a single changeset.
16. $ git rebase -  move branches around
Rebasing lets you move branches around, which helps you avoid unnecessary merge commits. The resulting linear history is often much easier to understand and explore.
17.$ git rebase i -  downloads a branch from another repository to add , eidt or delete commits 
The -i flag is used to. This provides all the benefits of a normal rebase, but gives you the opportunity to add, edit, or delete commits along the way.





18.git reflog - 
Git keeps track of updates to the tip of branches using a mechanism called reflog. This allows you to go back to changesets even though they are not referenced by any branch or tag.
19.git remote – to check the git remote 
A convenient tool for administering remote connections. Instead of passing the full URL to the fetch, pull, and push commands, it lets you use a more meaningful shortcut.
20.git reset - Undoes changes to files in the working directory. 
Undoes changes to files in the working directory. Resetting lets you clean up or completely remove changes that have not been pushed to a public repository.
21.git revert - Undoes a committed 
Undoes a committed snapshot. When you discover a faulty commit, reverting is a safe and easy way to completely remove it from the code base.

22.$ git status -
Displays the state of the working directory and the staged snapshot. You’ll want to run this in conjunction with git add and git commit to see exactly what’s being included in the next snapshot.

.........................................................................................................................................
How to revert a Pushed Commit -
There are two ways :: 
1.Push a new commit which reverts the pushed commit 
2.The right choice for public or shared branches
............................................................................................
1.Push a new commit which reverts the pushed commit 
$ git revert HEAD 
$ git push origin main 
2.The right choice for public or shared branches
$ git reset HEAD~1
$ git reset –hard HEAD-1
$ git push -f origin main 
3.How to revert a bad commit which is already pushed?
There can be cases where we want to revert from the pushed changes and go back to the previous version. To handle this, there are two possible approaches based on the situations:
    • Approach 1: Fix the bad changes of the files and create a new commit and push to the remote repository. This step is the simplest and most recommended approach to fix bad changes. You can use the command:  git commit -m "<message>"
    • Approach 2: New commit can be created that reverts changes done in the bad commit. It can be done using:  git revert <name of bad commit>
.........................................................................................................................................
How to revert a UnPushed Commit -  Revert Commit before push the Code - 
1. $  git reset --soft HEAD~1
2. $ git status
3. $ git log
4.  git commit -m "dwijendra1"
.........................................................................................................................................

Revert for push and unpushed commits – For Both -- 
1. $  git reset --soft HEAD~1   ( For Unpushed Commit )
2. $ git reset  --hard HEAD~1   ( For Pushed Commit )
.........................................................................................................................................
Some Questions and Problems we have to solve many Times :: 
1. git revert -
Undoes a committed snapshot. When you discover a faulty commit, reverting is a safe and easy way to completely remove it from the code base.
.........................................................................................................................................





Understand Git through Images ::: 

  
.........................................................................................................................................




.........................................................................................................................................


.........................................................................................................................................


.........................................................................................................................................

.........................................................................................................................................


.........................................................................................................................................
Branching Strategy :: 
Some Questions based on git -- 
1.  I have add the file in git how can i revert that --
$ git reset 
this is the command where your files will be reset 
....................
2.git reset <file>

....................
Note - 
1.If a file is added in git -
for example - 
dk.py is the file 
i remove it by command - $ rm dk.py 
then it will be remove from the files - 
                                 ......................................................

How to Resolve The Conflicts in Git ??
The easiest way to resolve a conflicted file is to open it and make any necessary changes. After editing the file, we can use the git add a command to stage the new merged content. The final step is to create a new commit with the help of the git commit command. Git will create a new merge commit to finalize the merge.
There are a few steps that could reduce the steps needed to resolve merge conflicts in Git.
1.The easiest way to resolve a conflicted file is to open it and make any necessary changes.
2.After editing the file, we can use the git add a command to stage the new merged content.
3.The final step is to create a new commit with the help of the git commit command.
4.Git will create a new merge commit to finalize the merge.
Git Commands to Resolve Conflicts::
1.git log –merge 
the git log –merge command helps to produce the list of commits that are causing the conflict.
2.git diff 
The git diff command help to identify the differences between the stage repositories of files.
3.git checkout 
The git checkout command is used to undo the changes made to the file,or changing branches.
4.git reset –mixed
the git reset –mixed command is used to undo changes to the working directory and staging area.
5.git merge –abort 
The git merge –abort command helps in exiting the merge process and returning back to the state before the merging began.
6.git reset 
The git reset command is used at the time of merge conflict to reset the conficted files to their original state.
................................................................................................................

Some theorotical questions for understanding of Git :: 
1. What is the functionality of “git cherry-pick” command?
This command is used to introduce certain commits from one branch onto another branch within the repository. The most common use case is when we want to forward- or back-port commits from the maintenance branch to the development branch.
2. What is the diff between git reset and git revert ?
Can you tell the differences between git revert and git reset?
git revert
git reset
This command is used for creating a new commit that undoes the changes of the previous commit.
This command is used for undoing the local changes done in the git repository
Using this command adds a new history to the project without modifying the existing history
This command operates on the commit history, git index, and the working directory.

3.What is git rebase command ?
What is git rebase? Rebasing is the process of moving or combining a sequence of commits to a new base commit. Rebasing is most useful and easily visualized in the context of a feature branching workflow.











Some Specific Important Commands :: 
1. $  git log --all --graph --decorate –oneline
It will show all the commits in the decorative way with oneline 
2. git log --all --graph –decorate
It will show all the commits in the decorative way with oneline
3.git mv a.py b.py 
this above command is after the git add a.py 
if i run this command then i will change this name in the staging area.also it is changed in sublime.
.........................................................................................................................................
How to Delete Commits in git - 
- Usually, we want to delete commits when we don’t want to leave any record of an embarrassing commit, or just for removing useless changes.
- This is achieved moving the branch or HEAD pointers. Moving the pointers to previous commits makes the commits remaining ahead get “lost”, unlinked from the linked list. To move them, reset command is used.
- There are two ways of making a reset: not touching the working directory (soft reset,--soft flag), or resetting it too (hard reset,--soft flag). That is, if you make a soft reset, the commit(s) will be removed, but the modifications saved in that/those commit(s) will remain; and a hard reset, won’t leave change made in the commit(s). If no flag is specified, the reset will be done softly.
Let’s start resetting things. The following command would remove the last commit, i.e., the commit where HEAD s pointing to:

1
git reset --hard HEAD~

The ~ character is for indicating an ancestor. Used once, indicates the immediate parent; twice, the grandparent; and so on. But, instead of typing ~ n times, we can specify the n ancestors that we want to remove:
1
git reset --hard HEAD~3

Which would remove the last 3 commits.
You may have noticed that this may cause conflicts with those commits with more than one ancestor, i.e., the result of a not fast-forwarded merge. Well, it doesn’t cause any problem: the followed parent using   HEAD~   is always the first one. But there’s a way to decide which of the common parents follow: ^, followed by the parent number. So, the following:
1
git reset --hard HEAD~2^2

Would remove the previous two commits, but taking the path of the second ancestor.
Even if it is possible to specify which ancestor path follow, is recommended to always use the syntax for first ancestor (only ~) since it’s easier, even if more commands would be required (since you would have to checkout the different branches to update HEAD position).
..............................................................................................................................................................
Some git reflog commands :: 
$ git reflog show
$ git reflog --pretty=short
$ git reflog --date=iso
$ git log -g
$ git reflog --pretty='%cd %h %gd %gs'
$ git reflog --format='%C(auto)%h %<|(20)%gd %C(blue)%cr%C(reset) %gs (%s)'
$ git reflog @{now}    
$ git reflog @{0}
$ git reflog --date=relative
$ git config --global alias.rl "reflog --date=relative"
$ git rl -10
$ git reflog --pretty='%Cred%h%Creset -%C(auto)%d%Creset %gs %Cgreen(%cr) %C(bold blue)<%an>%Creset'
$ git reflog --pretty='%Cred%h%Creset -%C(auto)%d%Creset %gs %Cgreen(%ad) %C(bold blue)<%an>%Creset'
$ git reflog --pretty=medium
$ git log --walk-reflogs –date=iso

Some more Important git reflog commands ::
$ git reflog show –all


..............................................................................................................................................................
Git Reflog vs Git log  :: 
People often misunderstand git log and git reflog. These two identically titled commands allow developers to examine the repository's commit history via the command line.
The git log is a public record of the commit history of the repository, whereas the reflog is private. This is the key difference between git log and reflog. After a fetch, push, or pull, the git log is duplicated as part of the git repository. In that situation, the git reflog is absent.
Unless any parameters are provided to the command, the git log only outputs from the current branch by default. However, git reflog will show you the available history of the git HEAD ref. Deleted commits and branches are ignored from the git log output since it focuses on the current branch history. Reflog, on the other hand, will always keep track of these deleted references.
Important Point :: 
Git reflog is an isolated store used to maintain an accurate running history of modifications made to your repository's HEAD pointer. It is unaffected by destructive operations like “git reset —hard”. Also, git reflog can be used to recover lost commits or branches in the repository.
* While "git reflog" is quite useful for recovering lost branches and commits, it has a few drawbacks. Because reference logs are saved locally, they cannot be pushed or fetched from a remote repository. They normally expire or be erased after a certain length of time to conserve disc space. By default, after 90 days the git reflog will be erased. This can be changed using Git's garbage collection configuration. The reflog cannot be used to retrieve data for Git objects that have been removed due to garbage collection.
*   - Very Importnant 
................................................................................................................................................
git gc command ::::::::::::::::::::::::::  $ git gc 
The "gc" stands for garbage collection. Executing git gc is literally telling Git to clean up the mess it's made in the current repository. Garbage collection is a concept that originates from interpreted programming languages which do dynamic memory allocation.
$ git gc 
................................................................................................................................................
git stash  command ::::::::::::::::::::::::::  $ $ git stash pop &  $ git stash apply
Imp :: Sometimes you want to switch the branches, but you are working on an incomplete part of your current project. You don't want to make a commit of half-done work. Git stashing allows you to do so. The git stash command enables you to switch branches without committing the current branch.
Generally, the stash's meaning is "store something safely in a hidden place." The sense in Git is also the same for stash; Git temporarily saves your data safely without committing.
The git stash command takes your uncommitted changes (both staged and unstaged), saves them away for later use, and then reverts them from your working copy.
$ git stash pop
You can reapply previously stashed changes with git stash pop.Popping your stash removes the changes from your stash and reapplies them to your working copy.
$ git stash apply
Alternatively, you can reapply the changes to your working copy and keep them in your stash with git stash apply:

Some More stash Command :: 
$ git status  
From the above output, you can see the status
$ git stash 
In the given output, the work is saved with git stash command. We can check the status of the repository
$ git stash save "<Stashing Message>"  
Git Stash Save (Saving Stashes with the message):
In Git, the changes can be stashed with a message. To stash a change with a message, run the above command.
$ git stash list  
Git Stash List (Check the Stored Stashes)
To check the stored stashes, run the below command:
$ git stash apply  
The above output restores the last stash. Now, if you will check the status of the repository, it will show the changes that are made on the file. 
From the above output, you can see that the repository is restored to its previous state before stash. It is showing output as "Changes not staged for commit."
$ git stash apply <stash id>  
In case of more than one stash, you can use "git stash apply" command followed by stash index id to apply the particular commit. It is used as above.
$ git stash show  
The above output illustrates that there are two files that are stashed, and two insertions performed on them.
We can exactly track what changes are made on the file. To display the changed content of the file, perform the below command:
$ git stash show -p  
Here, -p stands for the partial stash. The given command will show the edited files and content, consider the below output:
$ git stash pop
Git allows the user to re-apply the previous commits by using git stash pop command. The popping option removes the changes from stash and applies them to your working file.
The git stash pop command is quite similar to git stash apply. The main difference between both of these commands is stash pop command that deletes the stash from the stack after it is applied.
The above command will re-apply the previous commits to the repository. Consider the below output.

$ git stash drop 
The git stash drop command is used to delete a stash from the queue. Generally, it deletes the most recent stash. Caution should be taken before using stash drop command, as it is difficult to undo if once applied.
The only way to revert it is if you do not close the terminal after deleting the stash. The stash drop command will be used as:
       $ git stash drop <stash id>
We can also delete a particular stash from the queue. To delete a particular stash from the available stashes, pass the stash id in stash drop command. It will be processed as:
Assume that I have two stashes available in my queue, and I don't want to drop my most recent stash, but I want to delete the older one. Then, it will be operated as above command 

$ git stash clear 
The git stash clear command allows deleting all the available stashes at once. To delete all the available stashes, operate above command.
it will delete all the stashes that exist in the repository.



$ git stash branch <Branch Name>
If you stashed some work on a particular branch and continue working on that branch. Then, it may create a conflict during merging. So, it is good to stash work on a separate branch.
The git stash branch command allows the user to stash work on a separate branch to avoid conflicts. The syntax for this branch is as above.
The above command will create a new branch and transfer the stashed work on that. Consider the below output:


..............................................................................................................................
git rebase  command ::::::::::::::::::::::::::
A Git rebase changes the base of the developer's branch from one commit to another.
so it looks like they have created their branch from a different commit. Internally, Git creates a new commit and applies it to the specified base.
“”””  
Rebasing is the process of moving or combining a sequence of commits to a new base commit. Rebasing is most useful and easily visualized in the context of a feature branching workflow.
“”””
git rebase also has additional command options that can be useful in more complex applications.
git rebase -- d means during playback the commit will be discarded from the final combined commit block.
      Git rebase -- p leaves the commit as is. It will not modify the commit's message or content and will still be an individual commit in the branches history.
      git rebase -- x during playback executes a command line shell script on each marked commit. A useful example would be to run your codebase's test suite on specific commits, which may help identify regressions during a rebase.
      ..............................................................................................................
      git reset  command ::::::::::::::::::::::::::
      Usage: git reset [file] 
This command unstages the file, but it preserves the file contents.
 
Usage:git reset [commit]
This command undoes all the commits after the specified commit and preserves the changes locally.

Usage:git reset –hard [commit] 
This command discards all history and goes back to the specified commit.

..............................................................................................................
git show  [commit]  :::::::::::::::::::::::::: 
This command shows the metadata and content changes of the specified commit.

..............................................................................................................
git tag  :::::::::::::::::::::::::: 
This command is used to give tags to the specified commit.
 
..............................................................................................................................
      ..............................................................................................................
      View a Particular Commit  ::::::::::::::::::::::::::
      You can see the detailed changes of a specific commit by using the show parameter and providing the ID or hash of the commit. This hash is unique for each commit made in your repository.
      $ git show c5caff40733ff352fe830e28dc14500eefba83c9
      $ git show c5caff
..............................................................................................................
..............................................................................................................



      Git diff command with a timeline  ::::::::::::::::::::::::::
      $ git diff main@{0} main@{1.day.ago} 
Timed reflogs ::
1.minute.ago
    • 1.hour.ago
    • 1.day.ago
    • yesterday
    • 1.week.ago
    • 1.month.ago
    • 1.year.ago
    • 2011-05-17.09:00:00
..............................................................................................................
..............................................................................................................

Revert Unstaged and Staged Changes  ::::::::::::::::::::::::::
You can restore the unstaged working tree files by using the checkout parameter. You need to provide a file path to update it. If the file path is not set, then git checkout will update the HEAD to set the specified branch as the current branch.
$ git checkout somefile.js

To restore a staged working tree file, you can use the reset \ parameter. You need to provide a file path to remove it from the staging area. This will not remove any changes or modifications done to the files, instead, the file will be considered as an unstaged file.
$ git reset HEAD somefile.js

If you want to unstage all staged files, then do not provide the file path.
$ git reset HEAD
..............................................................................................................
Rollback a Particular Commit   ::::::::::::::::::::::::::
You can roll back to a particular commit by using revert parameter and the commit ID. It will create a new commit, a copy of the provided commit ID, and add it to the current branch history.
$ git revert 1af17e
..............................................................................................................
..............................................................................................................
Abort a Conflicting Merge     ::::::::::::::::::::::::::
You can abort a conflicting merge by using the merge parameter and the –abort flag. It allows you to exit from the merge process and return to the state after which the merge began.
$ git merge --abort


You can also use the reset parameter to during a merge conflict to reset the conflicted files to a stable state.
$ git reset

Cache Your Login Credentials

You can cache your login credentials by using the config parameter and –global flag. It helps to avoid re-typing the username and password every time you perform a commit.
$ git config --global credential.helper cache
..............................................................................................................................
Difference Between git rebase and git merge :
Git rebase commands said as an alternative of git merge. However, they have some key differences:
Git Merge
Git Rebase
Merging creates a final commit at merging.
Git rebase does not create any commit at rebasing.
It merges all commits as a single commit.
It creates a linear track of commits.
It creates a graphical history that might be a bit complex to understand.
It creates a linear history that can be easily understood.
It is safe to merge two branches.
Git "rebase" deals with the severe operation.
Merging can be performed on both public and private branches.
It is the wrong choice to use rebasing on public branches.
Merging integrates the content of the feature branch with the master branch. So, the master branch is changed, and feature branch history remains consistence.
Rebasing of the master branch may affect the feature branch.
Merging preserves history.
Rebasing rewrites history.
Git merge presents all conflicts at once.
Git rebase presents conflicts one by one.
 
Useful Git Commands List ::
Command
Description
git init
Initialize a local Git repository
git clone repo_url
Clone public repository
git clone ssh://git@github.com/[username]/[repository-name].git
Clone private repository
git status
Check status
git add [file-name]
Add a file to the staging area
git add -A
Add all new and changed files to the staging area
git commit -m "[commit message]"
Commit changes
git rm -r [file-name.txt]
Remove a file (or folder)
git branch
List of branches (the asterisk denotes the current branch)
git branch -a
List all branches (local and remote)
git branch [branch name]
Create a new branch
git branch -d [branch name]
Delete a branch
git branch -D [branch name]
Delete a branch forcefully
git push origin --delete [branch name]
Delete a remote branch
git checkout -b [branch name]
Create a new branch and switch to it
git checkout -b [branch name] origin/[branch name]
Clone a remote branch and switch to it
git branch -m [old branch name] [new branch name]
Rename a local branch
git checkout [branch name]
Switch to a branch
git checkout -
Switch to the branch last checked out
git checkout -- [file-name.txt]
Discard changes to a file
git merge [branch name]
Merge a branch into the active branch
git merge [source branch] [target branch]
Merge a branch into a target branch
git stash
Stash changes in a dirty working directory
git stash clear
Remove all stashed entries
git push origin [branch name]
Push a branch to your remote repository
git push -u origin [branch name]
Push changes to remote repository (and remember the branch)
git push
Push changes to remote repository (remembered branch)
git push origin --delete [branch name]
Delete a remote branch
git pull
Update local repository to the newest commit
git pull origin [branch name]
Pull changes from remote repository
git remote add origin ssh://git@github.com/[username]/[repository-name].git
Add a remote repository
git remote set-url origin ssh://git@github.com/[username]/[repository-name].git
Set a repository's origin branch to SSH
git log
View changes
git log --summary
View changes (detailed)
git log --oneline
View changes (briefly)
git diff [source branch] [target branch]
Preview changes before merging
git revert commitid
Revert commit changes
git config --global user.name "your_username"
Set globally Username
git config --global user.email "your_email_address@example.com"
Set globally Email id
git config --global --list
Get global config
 
Some Git Commit Commands :: 
git commit saves the changes in your local repository. Every time you commit your code changes, you have to include a brief description of the changes made. This commit message helps others understand the changes that have been done.
Usage
Commit any files added with the git add command and files that have been changed since then:
$ git commit -a 
Commit files with a message:
$ git commit -m “<commit message>”
You can replace the two previous commands with the following single command:
$ git commit -am “<commit – message>”

Modify the last commit with the latest changes as a new commit:
$ git commit –amend -m “<commit - message>”
