Example.txt ::


1. ExamplE of metaprogramming
2. ExamplE of monkey patching 
3. ExamplE of delegate method 
4. ExamplE of single table inheritance
5. ExamplE of multi table inheritance
6. ExamplE of duck typing
7. ExamplE of single ton method 
8. ExamplE of private/protected/public methods
9. ExamplE of method-overriding & method-overloading 
10.ExamplE of PORO-Plain Old Ruby Objects 
11.ExamplE of Scopes 
12.ExamplE of Procs 
13.ExamplE of Lambdas 
14.ExamplE of Garbage Collector 
15.ExamplE of Join and Include 
16.ExamplE of Design Pattern
17.ExamplE of Decorator Design Pattern
18.ExamplE of has_and_belongs_to_many and has_many_through association 
19.ExamplE of types of Joins in Rails 


Example of Ruby :: 
Print a Multi Dimensional Array ::

There are 3 types that we can flatten an array :: 

1.Flattening an Array by One Dimension
2.Flattening an Array n Times
3.Flattening an Array with Recursion

......................................................


There are 3 types that we can flatten an array :: 

1.Flattening an Array by One Dimension ::

my_array = [1, [2, 3, [4, 5]]]
single_flatten(my_array) #=> [1, 2, 3, [4, 5]]

................

def single_flatten(array)
  results = []
  array.each do |element|
    if element.class == Array
      element.each {|value| results << value}
    else
      results << element
    end
  end
  results
end

............
Exp :: 
This method takes in an array and sets an empty results array. It then looks at each element of the array in question. If the element is an array, it will look at each element within that array, and append the nested element’s value to the results array using the shovel operator. If the element is not an array, it will append the value of that element into the the results array. Once every element in the array has either had itself or its components appended into the results, the method returns the result array, which is equivalent to the original array flattened by one dimension:



......................


2.Flattening an Array n Times

my_array = [1, [2, 3, [4, [5, 6]]]]
multiple_flatten(my_array, 2) #=> [1, 2, 3, 4, [5, 6]]

................
def multiple_flatten(array, n)
  count = 0
  arr = array
  while count < n do
    arr = single_flatten(arr)
    count += 1
  end
  arr
end

Exp :: 

First, we set the count to zero and the variable arr to our initial array. If the counter hasn’t reached the number of dimensions we’ve specified wanting to reduce our array by, arr will be passed into single_flatten. Every time the block in the while loop executes, arr is reassigned to the result of single_flatten, and the counter is incremented by one. Once the counter is equal to the number of dimensions we want to reduce by, the final return value of the method is arr, the last result of the single_flatten.


......................

3.Flattening an Array with Recursion

my_array = [1, [2, 3, [4, 5]]]
recursive_flatten(my_array) #=> [1, 2, 3, 4, 5]

.................
def recursive_flatten(array, results = [])
  array.each do |element|
    if element.class == Array
      recursive_flatten(element, results)
    else
      results << element
    end
  end
  results
end

.................

Exp :: 


Like the single flatten, it checks if an element is an array, and if not, appends the value of the element to a results array. However, if the element is an array, the method calls itself pulling in this element and the existing results array. The method will keep calling itself on the elements of elements until all the elements are not arrays and can be pushed into the results array.

Because we want the method to be completely recursive, we’re setting results to an optional argument that defaults to an empty array. If we set the results array to be empty within the method, it will reset the results array every time the function is called. The first time we call recursive_flatten, we call it without the results argument. This way, it will create our initially empty results array that will then be filled passed around and into the other recursive_flatten methods and never be reset back to being empty!

......................


......................................................

............  ............  ............  ............ ............  ............  ............  ............  ............  ............ ............  ............ 

1. Meta programming 

# before meataprogramming 
class MyClass
  def red
    'red'
  end
  def blue
    'blue'
  end
  def green
    'green'
  end
  def yellow
    'yellow'
  end
end

# after meataprogramming 
class MyClass
  COLORS = ['red', 'blue', 'green', 'yellow']
  COLORS.each do |color|
    define_method color do
      color
    end
  end
end
............  ............  ............  ............ ............  ............  ............  ............  ............  ............ ............  ............ 

2. Monkey patching ::

# Before applying patching
hash = { "Geeks"=>"G","for"=>"F","geeks"=>"g" }
puts "Before blocking reverse: " hash.delete "for"
puts "Deleted 'for' key"
puts hash

# Apply patching
class Hash
  def delete(key)
    "Delete blocked!!"
  end
end

# After applying patching
hash = { "Geeks"=>"G","for"=>"F","geeks"=>"g" }      
puts "Before blocking reverse: "
puts "Deleting 'for' key but " + hash.delete("for")
puts hash

Output:
Before blocking reverse: 
Deleted 'for' key
{"Geeks"=>"G", "geeks"=>"g"}
Before blocking reverse: 
Deleting 'for' key but Delete blocked!!
{"Geeks"=>"G", "for"=>"F", "geeks"=>"g"}


............  ............  ............  ............ ............  ............  ............  ............  ............  ............ ............  ............ 

3. Delegation :: Delegate Method ::

Link :: https://medium.com/@pk60905/using-delegate-in-rails-527332da7f96
Example :: 

For example I have a QueueItem and aVideo model.

QueueItem < ActiveRecord::Base
  belongs_to :video
end
Video < ActiveRecord::Base
  has_many :queue_items
  belongs_to :category
end

...........

If I want to get the category object of the video in first queue_item, I may write

queue_item = QueueItem.first
queue_item.video.category.name
#=> "Action"

............

It is kind of cumbersome. Instead of getting the object via model association, we can use delegate to help us.

class QueueItem < ActiveRecord::Base
  belongs_to :video
 
  delegate :category, to: :video
end
Then we can get the category by

queue_item = QueueItem.first
queue_item.category.name
#=> "Action"
Or even you can set a category_name method in the QueueItem model.



class QueueItem < ActiveRecord::Base
  belongs_to :video
 
  delegate :category, to: :video
  def category_name
    category.name
  end
end
queue_item = QueueItem.first
queue_item.category_name
#=> "Action"
You can set one or more method names (specified as symbols or strings) if you want. And the name of the target object via the :to option(also a symbol or string).

There are some options you can use in delegation

:to — Specifies the target object
:prefix — Prefixes the new method with the target name or a custom prefix
:allow_nil — if set to true, prevents a NoMethodError to be raised
You can use the prefix option to make the method more readable.



class QueueItem < ActiveRecord::Base
  belongs_to :video
  delegate :category, to: :video
  delegate :title, to: :video, prefix: :video
end

queue_item = QueueItem.first
queue_item.video_title == queue_item.video.title
# => true

...................................................................

............  ............  ............  ............ ............  ............  ............  ............  ............  ............ ............  ............ 

4. Single table inheritance example :: 

rails generate model Expert name gender salary type
rails db:create db:migrate

# app/models/beard_dresser.rb
class BeardDresser < Expert
end

# app/models/hair_dresser.rb
class HairDresser < Expert
end

HairDresser.create(name: "John", gender: "male", salary: "10000")
BeardDresser.create(name: "Mike", gender: "male", salary: "9000")

HairDresser.count
=> 1

BeardDresser.count
=> 1

Expert.count
=> 2
............  ............  ............  ............ ............  ............  ............  ............  ............  ............ ............  ............ 
 
5. Example of observer 

A. simple email method to send email but our model job is not to send the emails so it breaks the single responsibility principle 
class User < Activerecord::Base
  after_save :send_email_notification

  private
  def send_email_notification
    if status_changed?
      UserNotificationMailer.account_open_email(self).deliver if status=='created'
      UserNotificationMailer.account_activated_email(self).deliver if status == 'active'
      UserNotificationMailer.account_deactivation_email(self).deliver if status =='deactive'
    end
  end
end


B. 
class UserObserver < ActiveRecord::Observer
  def after_save(record)
    if record.status_changed?
      UserNotificationMailer.account_open_email(record).deliver if record.status=='created'
      UserNotificationMailer.account_activated_email(record).deliver if record.status == 'active'
      UserNotificationMailer.account_deactivation_email(record).deliver if record.status =='deactive'
    end
  end
end
............  ............  ............  ............ ............  ............  ............  ............  ............  ............ ............  ............ 

C. 
Use single observer for multiple models ::
.............

............  ............  ............  ............ ............  ............  ............ ............  ............  ............  ............ .............

6. example of callback ::

A. 
class Subscription < ActiveRecord::Base
   before_create :record_signup
   private
   def record_signup
      self.signed_up_on = Date.today
   end
end

B.

.............

7. Example of Duck typing ::







...............

8. example of multi table inheritance ::




...............

...........  ............  ............  ............ ............  ............  ............ ............  ............  ............  ............ ............

9. Example of SingeTon Method ::

# Ruby program to demonstrate the use 
# of singleton methods
o1 = String.new 

# object1(o1)
o1 = "GeeksforGeeks"
o2 = String.new 
  
# object2(o2)
o2 = "GoodExample"
  
# Singleton method of object o2 
def o2.size     
 return "Size does not matter"
end
   
puts "Singleton Method Example:"
puts "Invoke from the object(o1):"
  
# Returns the size of string "Example1"
puts o1.size 
puts "Invoke from the object(o2):"
  
# Returns the o2.size method’s
# return statement
puts o2.size

Output:

Singleton Method Example:
Invoke from the object(o1):
13
Invoke from the object(o2):
Size does not matter

...........  ............  ............  ............ ............  ............  ............ ............  ............  ............  ............ .............

Example of sort array :: 

#Using bubble sort algorithm in ruby

a = [1,5,7,2,3,50,78,34,89]

a.size.times.each do |t|
 i=0
 a.each do |b|
   if b > a[i+1]
     a[i],a[i+1] = a[i+1],a[i]
   end
   i+=1 if i < a.size-2
 end
end
print a


# with swapped true method 

def my_sort(list)
  return list if list.size <= 1 

  swapped = false
  while !swapped
    swapped = false
    0.upto(list.size-2) do |i|
      if list[i] > list[i+1]
        list[i], list[i+1] = list[i+1], list[i]
        swapped = true
      end
    end
  end

  list
end

print my_sort([2,1,3,5,4,40])


...........  ............  ............  ............ ............  ............  ............ ............  ............  ............  ............ .............


